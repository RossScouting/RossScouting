<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Track and Field Simulator</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: Arial, sans-serif;
    }
    .track-container {
      position: relative;
      width: 600px;
      height: 300px;
    }
    svg {
      position: absolute;
      top: 0;
      left: 0;
    }
    .runner {
      position: absolute;
      width: 16px;
      height: 16px;
      border-radius: 50%;
    }
    #runner1 {
      background: red;
    }
    #runner2 {
      background: blue;
    }
    #raceTimer {
      font-size: 20px;
      margin: 10px;
    }
    label {
      margin: 5px;
    }
  </style>
</head>
<body>
  <h1>Track and Field Simulator</h1>
  <div>
    <label>Race Distance (m):
      <input type="number" id="raceDistance" value="400" />
    </label>
    <label>Runner 1 Time (s):
      <input type="number" id="runner1Time" value="50" />
    </label>
    <label>Runner 2 Time (s):
      <input type="number" id="runner2Time" value="55" />
    </label>
    <button onclick="startRace()">Start Race</button>
  </div>
  <div id="raceTimer">Time: 0.00s</div>
  
  <div class="track-container" id="trackContainer">
    <!-- SVG for drawing the track outline and markers -->
    <svg id="trackSVG" width="600" height="300"></svg>
    <!-- Runners -->
    <div class="runner" id="runner1"></div>
    <div class="runner" id="runner2"></div>
  </div>
  
  <script>
    /*************** Clockwise Track Geometry Setup ****************/
    // In "meter‑space", the original (clockwise) track is defined as:
    // Bottom straight: from (R, 0) to (R+100, 0)
    // Right curve (100–200m): centered at (R+100, R), arc from -90° to +90°
    // Top straight (200–300m): from (R+100, 2R) to (R, 2R)
    // Left curve (300–400m): centered at (R, R), arc from +90° to -90°
    const straightLength = 100; // meters per straight
    const curveArc = 100;       // meters per curve (arc length)
    const R = 100 / Math.PI;    // radius in meters (~31.83)
    
    // The track’s bounding box (in meters):
    const trackWidth_m = 100 + 2 * R;  // from x = R to x = R+100+R
    const trackHeight_m = 2 * R;       // from y = 0 to y = 2R
    
    // Scale factor to convert meters to pixels.
    const S = 3.6; // pixels per meter
    const containerWidth = 600;
    const containerHeight = 300;
    const offsetX = (containerWidth - trackWidth_m * S) / 2;
    const offsetY = (containerHeight - trackHeight_m * S) / 2;
    
    // Convert meter coordinates to pixel coordinates.
    function toPixel(pos) {
      return {
        x: pos.x * S + offsetX,
        y: pos.y * S + offsetY
      };
    }
    
    // Clockwise track position function (used for drawing the track).
    function getTrackPosition(d) {
      let x, y;
      if (d <= 100) {
        // Bottom straight: from (R, 0) to (R+100, 0)
        x = R + d;
        y = 0;
      } else if (d <= 200) {
        // Right curve: semicircle with center (R+100, R)
        const t = (d - 100) / 100; // 0 to 1
        const angle = -Math.PI/2 + t * Math.PI; // -90° to +90°
        x = (R + 100) + R * Math.cos(angle);
        y = R + R * Math.sin(angle);
      } else if (d <= 300) {
        // Top straight: from (R+100, 2R) to (R, 2R)
        x = (R + 100) - (d - 200);
        y = 2 * R;
      } else { // d in [300,400]
        // Left curve: semicircle with center (R, R)
        const t = (d - 300) / 100; // 0 to 1
        const angle = Math.PI/2 - t * Math.PI; // +90° to -90°
        x = R + R * Math.cos(angle);
        y = R + R * Math.sin(angle);
      }
      return { x, y };
    }
    
    /*************** Counterclockwise Runner Position ****************/
    // We want the same track shape but the runners to run counterclockwise.
    // The counterclockwise order (starting at the same start/finish line) is:
    // Segment 1 (0–100): Reversed left curve, going from (R,0) to (R,2R)
    // Segment 2 (100–200): Reversed top straight, from (R,2R) to (R+100,2R)
    // Segment 3 (200–300): Reversed right curve, from (R+100,2R) to (R+100,0)
    // Segment 4 (300–400): Reversed bottom straight, from (R+100,0) to (R,0)
    function getCCWTrackPosition(p) {
      // p: progress in meters along a 400m lap (0 <= p < 400)
      p = p % 400;
      let x, y;
      if (p <= 100) {
        // Segment 1: Reversed left curve.
        // Let u = p/100, then angle goes linearly from -π/2 to +π/2.
        const u = p / 100;
        const angle = -Math.PI/2 + u * Math.PI; // at u=0: -π/2, at u=1: +π/2
        // For a left curve, center is (R, R) and radius = R.
        x = R + R * Math.cos(angle);
        y = R + R * Math.sin(angle);
      } else if (p <= 200) {
        // Segment 2: Reversed top straight.
        // u goes from 0 to 1; linearly interpolate from (R,2R) to (R+100,2R).
        const u = (p - 100) / 100;
        x = R + u * 100;
        y = 2 * R;
      } else if (p <= 300) {
        // Segment 3: Reversed right curve.
        // u goes from 0 to 1; for right curve reversed, center is (R+100, R) with radius = R.
        // Angle goes from π/2 to -π/2.
        const u = (p - 200) / 100;
        const angle = Math.PI/2 - u * Math.PI;
        x = (R + 100) + R * Math.cos(angle);
        y = R + R * Math.sin(angle);
      } else {
        // Segment 4: Reversed bottom straight.
        // u goes from 0 to 1; interpolate from (R+100,0) to (R,0).
        const u = (p - 300) / 100;
        x = (R + 100) - u * 100;
        y = 0;
      }
      return { x, y };
    }
    
    /*************** Drawing the Track ****************/
    function drawTrack() {
      const svg = document.getElementById('trackSVG');
      svg.innerHTML = ''; // clear previous drawing
      
      // Use the clockwise positions for drawing.
      const p0   = toPixel(getTrackPosition(0));
      const p100 = toPixel(getTrackPosition(100));
      const p200 = toPixel(getTrackPosition(200));
      const p300 = toPixel(getTrackPosition(300));
      // p400 equals p0.
      
      const radiusPx = R * S;
      
      let pathStr = `M ${p0.x.toFixed(2)} ${p0.y.toFixed(2)} `;
      pathStr += `L ${p100.x.toFixed(2)} ${p100.y.toFixed(2)} `;
      pathStr += `A ${radiusPx.toFixed(2)} ${radiusPx.toFixed(2)} 0 0,1 ${p200.x.toFixed(2)} ${p200.y.toFixed(2)} `;
      pathStr += `L ${p300.x.toFixed(2)} ${p300.y.toFixed(2)} `;
      pathStr += `A ${radiusPx.toFixed(2)} ${radiusPx.toFixed(2)} 0 0,1 ${p0.x.toFixed(2)} ${p0.y.toFixed(2)} `;
      pathStr += 'Z';
      
      const pathElem = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      pathElem.setAttribute('d', pathStr);
      pathElem.setAttribute('fill', 'none');
      pathElem.setAttribute('stroke', 'black');
      pathElem.setAttribute('stroke-width', '2');
      svg.appendChild(pathElem);
      
      // Draw the start/finish line at d = 0.
      const finishLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      finishLine.setAttribute('x1', p0.x.toFixed(2));
      finishLine.setAttribute('y1', (p0.y - 10).toFixed(2));
      finishLine.setAttribute('x2', p0.x.toFixed(2));
      finishLine.setAttribute('y2', (p0.y + 10).toFixed(2));
      finishLine.setAttribute('stroke', 'red');
      finishLine.setAttribute('stroke-width', '2');
      svg.appendChild(finishLine);
      
      // Place markers at 0, 100, 200, and 300m (using clockwise positions).
      [0, 100, 200, 300].forEach(d => {
        const pos = toPixel(getTrackPosition(d));
        const marker = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        marker.setAttribute('cx', pos.x.toFixed(2));
        marker.setAttribute('cy', pos.y.toFixed(2));
        marker.setAttribute('r', '3');
        marker.setAttribute('fill', 'blue');
        svg.appendChild(marker);
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', (pos.x + 5).toFixed(2));
        text.setAttribute('y', (pos.y - 5).toFixed(2));
        text.setAttribute('font-size', '10');
        text.textContent = d + 'm';
        svg.appendChild(text);
      });
    }
    
    /*************** Race Animation ****************/
    function startRace() {
      const raceDistance = parseFloat(document.getElementById('raceDistance').value);
      const runner1Time = parseFloat(document.getElementById('runner1Time').value);
      const runner2Time = parseFloat(document.getElementById('runner2Time').value);
      
      // Draw the track outline.
      drawTrack();
      
      const runner1 = document.getElementById('runner1');
      const runner2 = document.getElementById('runner2');
      const raceTimer = document.getElementById('raceTimer');
      
      // Position runners at the start using counterclockwise mapping.
      const startPos = toPixel(getCCWTrackPosition(0));
      runner1.style.left = (startPos.x - 8) + 'px';
      runner1.style.top = (startPos.y - 8) + 'px';
      runner2.style.left = (startPos.x - 8) + 'px';
      runner2.style.top = (startPos.y - 8) + 'px';
      
      let startTime = null;
      function updateRace(timestamp) {
        if (!startTime) startTime = timestamp;
        let elapsed = (timestamp - startTime) / 1000;
        raceTimer.textContent = `Time: ${elapsed.toFixed(2)}s`;
        
        // For each runner, compute progress (in meters along the race), clamped to raceDistance.
        const progress1 = Math.min((elapsed / runner1Time) * raceDistance, raceDistance);
        const progress2 = Math.min((elapsed / runner2Time) * raceDistance, raceDistance);
        
        const pos1 = toPixel(getCCWTrackPosition(progress1));
        const pos2 = toPixel(getCCWTrackPosition(progress2));
        
        runner1.style.left = `${pos1.x - 8}px`;
        runner1.style.top = `${pos1.y - 8}px`;
        runner2.style.left = `${pos2.x - 8}px`;
        runner2.style.top = `${pos2.y - 8}px`;
        
        // Continue animating until both runners have finished.
        if (progress1 < raceDistance || progress2 < raceDistance) {
          requestAnimationFrame(updateRace);
        }
      }
      requestAnimationFrame(updateRace);
    }
  </script>
</body>
</html>
